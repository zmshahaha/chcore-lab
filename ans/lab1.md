> 思考题 1：阅读 `_start` 函数的开头，尝试说明 ChCore 是如何让其中一个核首先进入初始化流程，并让其他核暂停执行的。

从`mpidr_el1`中读取`AFF0 bits`,在**本体系结构上**就是当前核号，然后选取0号核运行，其他执行无限跳转当前位置即`while(1)`循环

> 练习题 2：在 `arm64_elX_to_el1` 函数的 `LAB 1 TODO 1` 处填写一行汇编代码，获取 CPU 当前异常级别。

```
	mrs x9, CurrentEL
```
之后使用定义的宏确定当前异常级别
```
#define CURRENTEL_EL1           (0b01 << 2)
#define CURRENTEL_EL2           (0b10 << 2)
```

> 练习题 3：在 `arm64_elX_to_el1` 函数的 `LAB 1 TODO 2` 处填写大约 4 行汇编代码，设置从 EL3 跳转到 EL1 所需的 `elr_el3` 和 `spsr_el3` 寄存器值。具体地，我们需要在跳转到 EL1 时暂时屏蔽所有中断、并使用内核栈（`sp_el1` 寄存器指定的栈指针）。

模仿EL2部分实例，写如下代码
```
	adr x9, .Ltarget
	msr elr_el3, x9
	mov x9, SPSR_ELX_DAIF | SPSR_ELX_EL1H
	msr spsr_el3, x9
```
设置elr_el3:`eret`后执行`ret`到`_start`

设置spsr_el3:`SPSR_ELX_EL1H`表示`eret`后是EL1，`SPSR_ELX_DAIF`表示`eret`后屏蔽所有中断

> 思考题 4：结合此前 ICS 课的知识，并参考 `kernel.img` 的反汇编（通过 `aarch64-linux-gnu-objdump -S` 可获得），说明为什么要在进入 C 函数之前设置启动栈。如果不设置，会发生什么？

反汇编后可发现有设置栈相关指令，具体作用如下：

1. 保护现场/上下文，如将寄存器压栈等。如果不设置栈，则可能会导致上下文信息缺失。

2. 传递参数，如果参数较少可以只用寄存器传参，而参数过多时（如超过 4 个）则需要用到栈来传参。如果不设置，则可能调用参数很多的 C 函数时无法将所有参数有效传递。

3. 保存临时变量，包括函数的非静态局部变量以及编译器自动生成的其他临时变量。如果不设置，则可能导致临时变量在内层函数中被调用甚至修改。

> 思考题 5：在实验 1 中，其实不调⽤ clear_bss 也不影响内核的执⾏，请思考不清理 .bss 段在之后的何种情况下会导致内核⽆法⼯作。

全局变量与静态变量没有初始化或者初始化值为 0 时，就会被放在 `.bss` 段。而由于存储在 `.bss` 段内的数据在下一次启动代码时不会被自动的重新初始化为 0，这就可能导致上一次运行代码过程中有可能修改了全局变量或静态变量的值，而修改过的值会被 `.bss` 段保存下来，那么在下一次启动代码时我们定义的全局变量的值可能就不是我们第一次定义的 `0` 值了，因此可能引发如地址越界等 `bug` 而导致内核无法正常工作。

**注意与普通程序不同点：普通程序加载时操作系统会将其`.bss`清零，而操作系统加载需要自己清零**

> 练习题 6：在 kernel/arch/aarch64/boot/raspi3/peripherals/uart.c 中 LAB 1 TODO 3 处实现通过 UART 输出字符串的逻辑。

```
    while(*str){
        early_uart_send(*str);
        str++;
    }
```

> 练习题 7：在 kernel/arch/aarch64/boot/raspi3/init/tools.S 中 LAB 1 TODO 4 处填写⼀⾏汇编代码，以启⽤ MMU。

模仿设置其他位代码，注意区别`bic`和`orr`

```
    orr x8, x8, #SCTLR_EL1_M
```
